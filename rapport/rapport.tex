\documentclass[a4paper,10pt]{article} %type de document et paramètres


\usepackage{lmodern} %police de caractère
\usepackage[english,french]{babel} %package de langues
\usepackage[utf8]{inputenc} %package fondamental
\usepackage[T1]{fontenc} %package fondamental

\usepackage[top=3cm, bottom=3cm, left=3cm, right=3cm]{geometry} %permet de

\usepackage[pdftex, pdfauthor={Maxime Flin, Pierre Gimalac}, pdftitle={Rapport projet}, pdfsubject={chatgroup with udp flooding}, pdfkeywords={UDP, chatgroup, flooding}, colorlinks=true, linkcolor=black]{hyperref}

\author{Maxime Flin \& Pierre Gimalac}
\title{Rapport de Projet}

\begin{document}
\maketitle

\begin{abstract}
  Ce rapport est un compte rendu du travail fourni pour le projet du cours de programmation réseau. Nous avons implémenté un chat décentralisé selon le protocole d'inondation décrit par Juliusz Chroboczek dans le sujet et \textbf{interopérable avec son implémentation}.

  Plusieurs extentions ont été devéloppées parmis lesquelles \textbf{l'agrégation de tlv(\ref{sec:agrega})}, \textbf{la fragmentation de gros messages(\ref{sec:frag})}, \textbf{quelques optimisations de l'innondation} et \textbf{l'implémentation d'une interface web(\ref{sec:web})}.
\end{abstract}

\section{Compilation et exécution\label{sec:exec}}
Les dépendances de ce projet sont...

Un \textrm{Makefile} est fournis pour compiler le projet:  \textit{'make all'}.\\

L'exécutable produit s'appelle \textit{chat}.
\begin{itemize}
\item \textrm{-- - port} ou \textrm{-p} suivi du numéro de port définit le port sur lequel lancer le server de chat. Si aucun port n'est précisé, il est alors choisit aléatoirement.
\item \textrm{- -webport} suivi du port sur lequel faire lancer le serveur web de l'application. Si aucun port n'est précisé, alors il est choisit aléatoirement entre 8080 et 8089.
\item \textrm{- -pseudo} suivit d'un pseudonyme. Un pseudonyme aléatoire est choisi dans une liste s'il n'est pas précisé.
\item \textrm{- -logs} ou \textrm{-l} suivit du chemin relatif vers un fichier où écrire les logs. Si le fichier n'existe pas il est créé. Si aucun fichier de log n'est précisé, les logs de l'application sont affichés sur la sortie standard d'erreur.
\end{itemize}

La commande suivante lance donc un serveur de chat sur le port 1212 accessible depuis une interface web sur le port 8089 (\href{localhost:8089}{localhost:8089}) et l'utilisateur de interface dans le terminal a pour pseudonyme Bob.

\begin{verbatim}
./chat --port 1212 --web-port 8089 --pseudo Bob
\end{verbatim}

Aucune option n'est necéssaire pour lancer le programme.

\section{Interface}

L'interface dans le terminal est en ligne de commande, elle interagit donc en lisant les commandes écrites sur l'entrée standard. \textbf{Une commande commence toujours par /}. Les commandes que propose notre application sont les suivantes:
\begin{description}
\item[add <addr> <port>] ajoute aux voisins potentiels les adresses associées à \textit{addr} et \textit{port}.
\item[name <name>] change le pseudonyme en \textit{name}.
\item[random] change le pseudonyme de manière aléatoire.
\item[print] affiche la liste des voisins et voisins potentiels.
\item[juliusz] équivalent à ``/add jch.irif.fr 1212''.
\item[neighbour] force l'envoi de tlv neighbour.
\item[clear] efface le terminal (fonctionne au moins sur bash et zsh).
\item[chid] change l'id de manière aléatoire.
\item[transfert <type> <path>] envoie le fichier \textit{path} avec le protocole de fragmentation. Quel que soit le fichier, il est envoyé avec le type donné. La description des types est données dans la section \ref{sec:frag}.
\item[help] affiche l'ensemble des commandes.
\item[quit] quitte programme, envoie des tlv goaway au passage.
\end{description}

Tout ce qui n'est pas une commande, ie. tout ce qui ne commence pas par un \textrm{/}, est un message qui sera envoyé sur le réseau. Le préfixe \textit{pseudo: } sera automatiquement ajouté devant le message.\\

Nous affichons par defaut (beaucoup) de logs sur la sortie d'erreur (comme dit dans la section \ref{sec:exec}, ils peuvent être redirigé dans un fichier avec l'option \textrm{logs}). Pour y voir plus clair, nous avons ajouté un code couleur au différents type de messages\footnote{Les couleurs peuvent être changées dans \textrm{interface.h}}. Nous avons choisi d'afficher la sortie standard dans la couleur normale, les logs en jaune et les erreurs en rouge. Pour ce faire nous avons implémenté la fonction \textit{cprint} dans \textit{utils} qui étends \textit{dprintf} en mettant les messages à la bonne couleur selon la sortie voulue.\\

Pour ajouter en voisin l'interface de Juliusz et envoyer les deux messages \textit{Bob: Bonjours tout le monde !} et \textit{Bob: Je suis très heureux de vous voir.}, il faudra donc entrer les commandes suivantes.

\begin{verbatim}
/add jch.irif.fr 1212
Bonjour tout le monde !
Je suis très heureux de vous voir.
\end{verbatim}

Une interface web a aussi été implémentée, mais étant une extention nous en reparlerons dans la section \ref{sec:web}.

\section{Fonctionnalitées}

\subsection{Sujet minimal}
Le sujet minimal a été entièrement implémenté.
Nous envoyons et recevons des messages...

Nous avons soumis notre implémentation à des séries de tests implacables pour tester son efficacité et sa resistance aux paquets buggés.


\textit{Les extentions suivantes sont présentées dans l'ordre dans lesquelles elles est ont été développées dans le projet.}

\subsection{Agrégation de TLV\label{sec:agrega}}
Les messages a envoyer sont stocké dans une file (plus de détails dans la section \ref{sec:implem}) de messages acccessible grâce à deux méthodes:

\begin{description}
\item[pull\_tlv] Retire un message à envoyer de la file des messages à envoyer.
\item[push\_tlv] Cette fonction attends un TLV et un voisin en paramètre. Elle ajoute le tlv donné à un message si avec cet ajout la taille du message reste plus petite que le PMTU de ce voisin. Si un tlv ne peut être inséré dans aucun message, un nouveau message est ajouté à la fin de la file.
\end{description}

Chaque voisin possède un attribu \textrm{PMTU} correspondant à une approximation inférieure du réel \textrm{PMTU} avec ce voisin. Nous avions envisagé d'améliorer cette approximation en implémentant une découverte de PMTU mais y avons rennoncé. La raison étant principalement due à la nécessité d'utiliser des sockets connectées pour ce faire ; notre application n'utilise qu'une seule socket (sans compter l'interface web), l'utilisation de sockets connectées représentait donc un travail que nous n'étions pas près à fournir.


\subsection{Fragmentation des gros messages\label{sec:frag}}
Nous avons implémenté le protocole de fragmentation de gros messages proposé par \textrm{Alexandre Moine} et \textrm{Tristan François} sur la mailing list du projet. Ils proposaient d'utiliser un nouveau type de data afin que les TLV puissent être innondés même par les pairs n'ayant pas implémenté la fragmentation et permettre à ceux qui l'avaient faite de reconstituer le message à l'arrivée.

Le format des TLV est le suivant:

\begin{verbatim}
         0                   1                   2                   3
         0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        |    Type = 4   |   Length      |                               |
        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+                               +
        |                            Sender Id                          |
        +                               +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        |                               |             Nonce             |
        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        |                               |   Type = 220  |               |
        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        |           Nonce du message fragmenté          |     Type      |
        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        |    Taille totale du message   |      Position du fragment     |
        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        |                      Fragment du message...
        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
\end{verbatim}

On reconnaît la structure d'un TLV Data auquel on a ajouté les champs \textit{Nonce du message fragmenté}, \textit{Type}, \textit{Taille totale du message}, \textit{Position du fragment} et \textit{Fragment}. Aussi le message est correctement inondé par les pairs qui n'ont pas implémenté le protocole, le \textit{Nonce} du data étant différent pour chaque message. Les fragments d'un même message peuvent être rassemblés grâce au champ \textit{Nonce du message fragmenté} partagé par tous les fragments de ce dernier.

Le champ type permet de savoir comment interpréter le message reçu. Au cours de nos échanges sur la mailing list, nous avons proposé les attributions suivantes qui ont été acceptés.

\begin{description}
\item[0] Texte UTF-8
\item[1] Non attribué
\item[2] Image gif
\item[3] Image jpg
\item[4] Image png
\item[5] SVG
\end{description}

Cette attribution de type nous permet notemment de différentier la reception d'un long texte de la reception d'une image. Si nous recevons une image nous pouvons alors l'afficher dans notre interface web.

Nous rassemblons tous les messages fragmentés que nous recevons, une analyse du type pourrait être faite pour ne pas s'encombrer de gros messages dont ne feront rien une fois rassemblés.

De rapides tests ont été fait avec \textrm{Alexandre Moine} et \textrm{Tristan François} pour s'assurer de l'interopérabilité de nos implémentations.

\subsection{Interface web, protocole HTTP et WebSocket\label{sec:web}}

Après avoir jetté un coup d'oeil à l'implémentation de l'interface web de julius, nous avons remarqué qu'il utilisait le protocole WebSocket pour communiquer entre son interface web (\href{http://jch.irif.fr:8082/}{http://jch.irif.fr:8082/}) et son application, accessible sur le port 1212. Nous aimions surtout l'idée d'implémenter une interface graphique, non pas grâce à l'utilisation d'une bibliothèque graphique lourde et compliquée, mais à travers l'implémentation d'un protocole réseau. De plus, le besoin d'une interface graphique se faisait ressentir à cause de la quantitée astronomique de logs que nous affichions, il nous a donc semblé que cette solution permettait de le faire tout en restant dans les bornes de ce cours.\\

Nous avons donc implémenté un serveur \textrm{HTTP}\footnote{\href{https://tools.ietf.org/html/rfc2616}{RFC2616}} très basique pour afficher une page web, créer la connection WebSocket et charger des images depuis un dossier temporaire. Il n'est pas très sécurisé et n'implémente pas tous les détails du protocole, nous sommes au courant, mais l'objectif étant d'avoir une interface graphique simple dans le navigateur et surtout d'implémenter le protocole WebSocket, nous avons mis de côté ces points là.\\

Nous avons ensuite implémenté le protocole \textrm{WebSocket}\footnote{\href{https://tools.ietf.org/html/rfc6455}{RFC6455}}. La connection WebSocket s'effectue après un ``\textit{Handshake}'' à travers une connection \textrm{HTTP} ayant le champs \textrm{Upgrade: websocket}. On reçoit une clef secrète \textrm{Sec-WebSocket-Key}, on la concatène à une ``\textit{magic string}'', on la hash avec \textrm{SHA1} puis on envoie une réponse \textrm{HTTP} de type 101 contenant le champ \textrm{Sec-WebSocket-Accept} ayant pour valeur l'encodage en base64 du hash. À partir de ce moment la connection TCP n'est plus fermée avant que l'un des deux pairs ne le decide.
Une trame WebSocket est au format suivant

\begin{verbatim}
          0                   1                   2                   3
          0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
         +-+-+-+-+-------+-+-------------+-------------------------------+
         |F|R|R|R| opcode|M| Payload len |    Extended payload length    |
         |I|S|S|S|  (4)  |A|     (7)     |             (16/64)           |
         |N|V|V|V|       |S|             |   (if payload len==126/127)   |
         | |1|2|3|       |K|             |                               |
         +-+-+-+-+-------+-+-------------+ - - - - - - - - - - - - - - - +
         |     Extended payload length continued, if payload len == 127  |
         + - - - - - - - - - - - - - - - +-------------------------------+
         |                               |Masking-key, if MASK set to 1  |
         +-------------------------------+-------------------------------+
         | Masking-key (continued)       |          Payload Data         |
         +-------------------------------- - - - - - - - - - - - - - - - +
         :                     Payload Data continued ...                :
         + - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - +
         |                     Payload Data continued ...                |
         +---------------------------------------------------------------+
\end{verbatim}

Le bit \textrm{FIN} est à 1 si sa charge utile (payload) est le dernier fragment de la séquence de fragments. \textrm{opcode} est un entier sur 4 bits qui encode le type du message.

\begin{description}
\item[0x0] La charge utile est la suite de celle de la trame précédente
\item[0x1] Texte
\item[0x2] Données binaires
  ...
\item[0x8] Fin de connection
\item[0x9] Ping
\item[0xA] Pong
\end{description}

L'échange de ping et de pong permet de s'assurer que le pair reçoit encore les messages, la reception d'un ping doit être suivie aussi vite que possible de l'envoi d'un pong. Notre implémentation du protocole n'envoie jamais de ping.

La communication entre le client web et notre serveur se fait à travers ce protocole.
\begin{enumerate}
\item Le client envoie du texte à travers la socket qui est interprétée comme celle de l'interface du terminal (sauf en ce qui concerne l'ajout du pseudo au debut).
\item Le serveur envoie du texte au client qui l'affiche tel quel dans le navigateur. Cette partie est source de potentielles failles de sécuritées (injection de javascript dans le client d'un autre), nous sommes au courant mais avons choisit d'ignorer le problème ayant d'autres choses à faire.
\end{enumerate}

\subsection{Extentions envisagées mais non développées}

\begin{description}
\item[Concurrence] % peut être déplacer dans extentions ?
\item[Très très gros messages]
\item[Sécurité cryptographique]
\end{description}

\section{Plus sur l'implémentation}
\subsection{Organisation}
Le fichier \textit{main} contient la boucle principale du programme, une fonction d'initialisation et des fonctions de gestion de l'entrée standard.\\

Le sous-dossier \textbf{structs} contient les structures de données utilisées dans le projet: hashmap, hashset, liste chaînée, arraylist.\\

Le fichier \textit{interface} contient les fonctions liées à l'interface (changement de pseudonyme, gestion de commandes, affichages des messages).\\

Les fichiers \textit{network} et \textit{flooding} contiennent les fonctions liées à l'inondation, à la réception et à l'envoi de messages.\\

Les fichiers \textit{tlv}, \textit{checkers}, \textit{handlers}, \textit{onsend} contiennent des fonctions de gestion de tlv (création, vérification et gestion à la réception,...).\\

La plupart des structures utilisées pour l'implémentation du protocole sont définies dans \textit{types.h}.\\

Le fichier \textit{util} contient des fonctions diverses utilisées tout au long du projet.

\subsection{Structures utilisées}
Les messages reçus récemment et les messages à inonder sont chacun stockés par une hashmap. Dans le second cas, il s'agit d'une hashmap de hashset (chaque hashset contient les voisins encore à inonder pour le message donné).

Les fragments de messages sont stockés dans une hashmap. [voir extensions]

Les messages à envoyer sont stockés dans une liste circulaire.

\subsection{Boucle principale}
La boucle principale fait dans l'ordre:
\begin{enumerate}
\item gestion des voisins symétriques: s'ils n'ont pas envoyé un hello long dans les deux dernières minutes, ils deviennent potentiels, sinon on leur envoie un hello long.
\item si le nombre de voisin symétrique n'est pas trop élevé, gestion des voisins potentiels: s'ils n'ont pas répondu à plus de 5 hellos courts, ils sont retirés, sinon on leur en envoie un autre.
\item inondation des messages aux voisins, si un voisin n'a pas envoyé de ack après 5 envois, il est rétrogradé en potentiel.
\item envoi de tlv neighbour aux voisins pour lesquels on ne l'a pas fait depuis 2 minutes.
\item on retire un par un les messages de la liste de messages et on les envoie.
\item suppression des vieux messages (ceux pour lesquels aucun data n'a été envoyé ou aucun ack reçu depuis plus de 45 secondes).
\item suppression des vieux fragments de messages (ceux pour lesquels aucun data n'a été envoyé ou aucun ack reçu depuis plus de 60 secondes) [voir extensions].
\item appel à \textit{select} sur STDIN et la socket utilisée, en donnant un timeout qui est le minimum des prochains moments où l'une des actions ci-dessus sera nécéssaire.
\item si STDIN est à lire, traitement de l'entrée standard (commande ou envoi de message).
\item s'il y a un message reçu, on va lire la socket un certains nombre de fois (pour éviter une congestion s'il y a beaucoup de messages reçus). Ce nombre est compris entre le nombre de voisins et deux fois le nombre de voisins et varie en fonction du nombre de messages reçus à chaque tour de boucle.
\end{enumerate}

\end{document}

 % - introduction : projet fait par machin et bidule.
 %  - manuel
 %     - comment compiler
 %     - comment s'en servir
 %  - partie qui marche
 %     - sujet minimal
 %     - extensions
 %  - partie qui ne marche pas
 %     - qui ne marche pas parce qu'on est incompétents
 %     - qui ne marche pas parce qu'on a eu la flemme
 %  - parties pompées sur les copains (à qui merci)
 %  - détails d'implémentation
 %     - structure générale du programme
 %     - parties non-triviales que je vous explique gentiment
 %     - parties super bien faites dont on est fiers
 %     - parties mal faites dont on a un peu honte mais qu'on a la flemme
 %       d'améliorer
 %  - commentaires sur le protocole
 %     - telle partie du protocole est mal faite, voici comment l'améliorer
 %     - telle partie du protocole est difficile à implémenter, je vous déteste
 %  - conclusion
 %     - ce sujet nous a énormément apporté, il nous a ouvert l'esprit et
 %       a amélioré nos performances sexuelles.
